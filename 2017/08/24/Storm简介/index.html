<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="SEU Linux Club"><title>Storm简介 · 东南大学Linux俱乐部</title><meta name="description" content="Storm的历史
Storm是由Nathan Marz和他的团队在BackType创建的。BackType是一家帮助公司和品牌衡量社交媒体影响力的数据分析公司。
后来BackType被Twitter公司收购之后，Storm被开源。
在很短的时间内Storm就成为了分布式实时处理系统的标准。
Stor"><meta name="keywords" content="Linux &amp; More"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Club Blog</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">SEU LINUX Blog</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li class="soc"><a href="https://github.com/SEULinuxClub" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://SEULinuxClub.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://SEULinuxClub.github.io" rel="noopener noreferrer">SEU Linux Club</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Storm简介</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2017-08-24</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/Storm/" title="Storm" class="a-tag">Storm</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="Storm的历史"><a href="#Storm的历史" class="headerlink" title="Storm的历史"></a>Storm的历史</h1><ul>
<li>Storm是由<strong>Nathan Marz</strong>和他的团队在<strong>BackType</strong>创建的。<strong>BackType</strong>是一家帮助公司和品牌衡量社交媒体影响力的数据分析公司。</li>
<li>后来<strong>BackType</strong>被<strong>Twitter</strong>公司收购之后，Storm被开源。</li>
<li>在很短的时间内Storm就成为了分布式实时处理系统的标准。</li>
<li>Storm由Java和Clojure语言写成。</li>
</ul>
<h1 id="Storm是什么"><a href="#Storm是什么" class="headerlink" title="Storm是什么"></a>Storm是什么</h1><p>​    Apache Storm 是一个分布式实时大数据处理系统。Storm是为使用具有容错性和横向可伸缩的方法处理大量的数据而设计。它是一个高摄取率的流式数据框架。虽然Storm是无状态的，但是它使用Apache ZooKeeper来管理分布式环境和团簇状态。它简单易用，可以并行的对实时数据做各种操作。</p>
<p>​    Apache Storm仍然是实时数据处理的领导者。Storm易于部署、操作，并且它可以保证每一个信息至少通过拓扑结构处理一次。</p>
<h1 id="Apache-Storm-vs-Hadoop"><a href="#Apache-Storm-vs-Hadoop" class="headerlink" title="Apache Storm vs Hadoop"></a>Apache Storm vs Hadoop</h1><p>​    总体上讲Storm和Hadoop都是用来处理大数据的框架。它们互为补充，在某一些方面不同。Storm不具有持续性，而Hadoop没有实时处理能力。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Storm</th>
<th style="text-align:center">Hadoop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实时流处理</td>
<td style="text-align:center">批处理</td>
</tr>
<tr>
<td style="text-align:center">无状态</td>
<td style="text-align:center">有状态</td>
</tr>
<tr>
<td style="text-align:center">基于ZooKeeper协调的主从结构。主节点称为雨云(Nimbus)，从节点称为监督者(Supervisor)</td>
<td style="text-align:center">无论是否使用ZooKeeper都为主从结构。主节点称为作业追踪器(Job tracker)，从节点称为任务追踪器(Task tracker)</td>
</tr>
<tr>
<td style="text-align:center">在一个簇中，一个Storm流过程每秒可以访问上万条信息。</td>
<td style="text-align:center">Hadoop分布式文件系统(HDFS)使用映射规约(MapReduce)框架，用几分钟或几小时处理大量数据。</td>
</tr>
<tr>
<td style="text-align:center">Storm拓扑会一直执行直到用户关闭或者出现了不可恢复的异常。</td>
<td style="text-align:center">映射规约任务顺序执行，最终结束。</td>
</tr>
<tr>
<td style="text-align:center">分布式、具有容错性</td>
<td style="text-align:center">分布式、具有容错性</td>
</tr>
<tr>
<td style="text-align:center">如果主/从节点挂掉，重启之后会继续原来的工作，不会有任何影响。</td>
<td style="text-align:center">主节点挂掉会丢失所有执行中的任务。</td>
</tr>
</tbody>
</table>
<h1 id="Apache-Storm-的用例"><a href="#Apache-Storm-的用例" class="headerlink" title="Apache Storm 的用例"></a>Apache Storm 的用例</h1><ul>
<li>Twitter：Twitter使用Storm来做发布者分析。发布者分析处理每一个用户动态和Twitter平台的点击数。</li>
<li>NaviSite：NaviSite使用Storm作为日志监视系统。系统生成的每一条日志都会经过Storm，由Storm来检查这条信息是否被特定的正则表达式匹配。如果可以匹配，这条信息就会存入数据库。</li>
<li>Wego：Wego是一个旅行数据搜索引擎，它使用Storm来搜索实时的旅游数据并反馈给用户最佳匹配结果。</li>
</ul>
<h1 id="Storm的优势"><a href="#Storm的优势" class="headerlink" title="Storm的优势"></a>Storm的优势</h1><ol>
<li>Storm开源、健壮、对用户友好。</li>
<li>Storm具有容错性、灵活性、可靠性，并且支持各种编程语言。</li>
<li>实时流处理。</li>
<li>快速。</li>
<li>高度可定制。</li>
<li>低延迟。</li>
<li>智能运行。</li>
<li>即使团簇中相连的节点挂掉或者信息丢失也不会影响数据的处理。</li>
</ol>
<h1 id="Apache-Storm-的核心概念"><a href="#Apache-Storm-的核心概念" class="headerlink" title="Apache Storm 的核心概念"></a>Apache Storm 的核心概念</h1><p>​    Apache Storm 从一端读取未经处理的实时数据流，然后让这些数据通过一系列小的处理单元，最后向另一端输出处理过的信息。</p>
<p><img src="https://raw.githubusercontent.com/ZizhuoWang/ImageBed/network/storm.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tuple元组</td>
<td style="text-align:left">元组是Storm的主要数据结构，它是一个有顺序的元素列表。元组默认支持所有数据类型。一般来说元组是以逗号分隔的值的集合。</td>
</tr>
<tr>
<td style="text-align:center">Stream流</td>
<td style="text-align:left">流是一系列无序的元组。</td>
</tr>
<tr>
<td style="text-align:center">Spout龙卷</td>
<td style="text-align:left">龙卷是流的源头。Storm可以接受Twitter Streaming API, Apache Kafka queue, Kestrel queue等等未经处理的数据源的输入数据，也可以自己写一个龙卷来从数据源读取数据。”ISpout”是实现龙卷的核心接口，还有一些具体的接口，比如IRichSpout, BaseRichSpout, KafkaSpout等等。</td>
</tr>
<tr>
<td style="text-align:center">Bolts 闪电</td>
<td style="text-align:left">闪电是逻辑处理单元。龙卷将数据传给闪电，闪电处理并产生新的输出流。闪电和数据源、数据库一起可以做过滤，聚合，连接，交互操作。闪电会获取数据并将数据传给一个或多个闪电。”IBolt”是实现闪电的核心接口，还有一些常用的接口，比如IRichBolt, IBasicBolt等等。</td>
</tr>
</tbody>
</table>
<h1 id="实例：Twitter-Analysis"><a href="#实例：Twitter-Analysis" class="headerlink" title="实例：Twitter Analysis"></a>实例：Twitter Analysis</h1><p>​    Twitter Analysis的输入数据来自Twitter Streaming API。龙卷会使用Twitter Streaming API来读取用户的”Tweets”，然后输出元组流。龙卷输出的一个元组里包含一个Twitter用户名和一条Tweet，用逗号分隔。之后，这个元组流会被送到闪电那里去，闪电会将每一条Tweet分词、计算词数并且将这些信息保存到指定的数据源中，之后我们可以查询数据源来获得结果。</p>
<h1 id="Topology-拓扑结构"><a href="#Topology-拓扑结构" class="headerlink" title="Topology 拓扑结构"></a>Topology 拓扑结构</h1><p>​    龙卷和闪电相连形成拓扑结构。实时应用的逻辑在Storm的拓扑结构中指定。简单来说，拓扑结构是一个有向图，图的节点指代计算，图的边代表数据流。</p>
<p>​    一个简单的拓扑结构一般从龙卷开始，龙卷将数据提交给一个或多个闪电。闪电代表的是拓扑结构中拥有最小处理逻辑的节点。每一个闪电的输出结果都可以作为另一个闪电的输入数据。</p>
<p>​    Storm会保持拓扑结构的运行，直到手动关闭这个拓扑。</p>
<h1 id="Tasks-任务"><a href="#Tasks-任务" class="headerlink" title="Tasks 任务"></a>Tasks 任务</h1><p>​    现在我们已经了解了龙卷和闪电的基本概念，他们是拓扑结构的最小逻辑单元，拓扑结构由一个龙卷和一组闪电构成。为了正确执行拓扑，这一个龙卷和一组闪电必须按照一个指定的顺序执行。</p>
<p>​    Storm中所有的龙卷和闪电的执行称为任务。简单来说，一个任务要么是龙卷的执行，要么是闪电的执行。在给定的时间里，每一个龙卷和每一个闪电都可以有多个实例运行在多个不同的线程中。</p>
<h1 id="Workers-工人"><a href="#Workers-工人" class="headerlink" title="Workers 工人"></a>Workers 工人</h1><p>​    拓扑是分布式运行在多个工人节点上的。Storm 将任务平均地分给所有的工人节点。工人节点的责任是监听是否有工作到来，并且当新工作到来时开始或停止进程。</p>
<h1 id="Stream-Grouping-流分组"><a href="#Stream-Grouping-流分组" class="headerlink" title="Stream Grouping 流分组"></a>Stream Grouping 流分组</h1><p>​    数据流从龙卷流向闪电，或者从一个闪电流向另一个闪电。流分组控制拓扑中元组的走向，帮助我们理解拓扑中的元组流。以下介绍四种内置的分组方式。</p>
<h2 id="Shuffle-Grouping-随机分组"><a href="#Shuffle-Grouping-随机分组" class="headerlink" title="Shuffle Grouping 随机分组"></a>Shuffle Grouping 随机分组</h2><p>​    在随机分组中，等量的元组随机分配给所有执行闪电的工人。</p>
<p><img src="https://www.tutorialspoint.com/apache_storm/images/shuffle_grouping.jpg" alt=""></p>
<h2 id="Field-Grouping-字段分组"><a href="#Field-Grouping-字段分组" class="headerlink" title="Field Grouping 字段分组"></a>Field Grouping 字段分组</h2><p>​    字段中具有相同值的元组被分成一组，传给同一个工人。</p>
<p><img src="https://www.tutorialspoint.com/apache_storm/images/field_grouping.jpg" alt=""></p>
<h2 id="Global-Grouping-全局分组"><a href="#Global-Grouping-全局分组" class="headerlink" title="Global Grouping 全局分组"></a>Global Grouping 全局分组</h2><p>​    所有的流被分为一组发送给一个闪电。这种分组策略将数据源的所有实例生成的所有元组发送给一个目标实例，特指ID最低的工人。</p>
<p><img src="https://www.tutorialspoint.com/apache_storm/images/global_grouping.jpg" alt=""></p>
<h2 id="All-Grouping-全分组"><a href="#All-Grouping-全分组" class="headerlink" title="All Grouping 全分组"></a>All Grouping 全分组</h2><p>​    全分组将每一个元组发给作为接收方的那个闪电的所有实例。这种分组方式被用来向闪电发送信号，还有利于合并操作。</p>
<p><img src="https://www.tutorialspoint.com/apache_storm/images/all_grouping.jpg" alt=""></p>
<h1 id="Cluster-Architecture-簇结构"><a href="#Cluster-Architecture-簇结构" class="headerlink" title="Cluster Architecture 簇结构"></a>Cluster Architecture 簇结构</h1><p>​    Apache Storm的亮点之一就是它是一个高速、具有容错性、没有单点故障的分布式程序。我们可以任意地将Storm安装在大量的系统中来增加应用的容量。</p>
<p>​    现在我们来看一下Apache Storm的簇是如何设计的。</p>
<p><img src="https://www.tutorialspoint.com/apache_storm/images/zookeeper_framework.jpg" alt=""></p>
<ul>
<li>Apache Storm 有两种类型的节点，雨云（主节点）和监督者（从节点）。<ul>
<li>雨云是Apache Storm 的核心组件，它的主要工作是运行Storm拓扑。雨云分析拓扑结构并且收集将要执行的任务，之后它将任务分配给一个空闲的监督者。</li>
</ul>
</li>
</ul>
<ul>
<li>监督者会包含一个或多个工人进程，它将任务分发给各个工人进程。工人进程会生成所需数目的执行者来执行任务。</li>
</ul>
<ul>
<li>Apache Storm使用一个内部的分布式消息系统，雨云和监督者之间交流更方便。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">雨云Nimbus</td>
<td style="text-align:center">雨云是Storm簇的主节点，簇中其他的节点都是worker nodes工人节点/从节点。雨云/主节点负责向所有的从节点分发数据、指定任务和监控错误。</td>
</tr>
<tr>
<td style="text-align:center">监督者Supervisor</td>
<td style="text-align:center">听从雨云指令的节点称为监督者/从节点，一个监督者包含一个或多个工人进程。监督者监督工人进程完成雨云指定的任务。</td>
</tr>
<tr>
<td style="text-align:center">工人进程Worker Process</td>
<td style="text-align:center">工人进程执行与特定拓扑相关的任务，但是它自身不执行任务，而是产生执行者，让执行者执行特定的任务。一个工作进程包含多个执行者。</td>
</tr>
<tr>
<td style="text-align:center">执行者Executor</td>
<td style="text-align:center">执行者是由工人进程产生的线程，它可以执行一个或者多个任务，但是它只为一个龙卷Spout或一个闪电Bolt服务。</td>
</tr>
<tr>
<td style="text-align:center">任务Task</td>
<td style="text-align:center">任务执行实际的数据处理，所以它是龙卷或者闪电。</td>
</tr>
<tr>
<td style="text-align:center">ZooKeeper框架</td>
<td style="text-align:center">Apache ZooKeeper是被簇用来协调节点、以健壮的同步机制管理共享数据的服务。雨云是无状态的，所以它依靠ZooKeeper来监控处于工作状态的节点的状态。ZooKeeper帮助监督者与雨云交互，负责维持雨云和监督者的状态。</td>
</tr>
</tbody>
</table>
<p>​    Storm从设计之初就是无状态的，虽然无状态有它的缺点，但是它使得Storm能够以最优最快的方式处理实时数据。</p>
<p>​    但是Storm也不是完全无状态的，它的状态存储在Apache ZooKeeper里。正因如此，一个挂掉的雨云可以从它挂的地方重新启动，继续工作。像<strong>monit</strong>这种监控雨云的程序可以在错误发生后重启雨云。</p>
<p>​    Apache Storm还有一种高级的拓扑叫做Trident Topology(三叉戟拓扑)，它在提供处理大吞吐量数据的能力的同时，也提供了低延时分布式查询和有状态流式处理的能力。它还提供了高级的API，比如Pig。</p>
<h1 id="Apache-Storm-的工作流"><a href="#Apache-Storm-的工作流" class="headerlink" title="Apache Storm 的工作流"></a>Apache Storm 的工作流</h1><p>​    一个可以运行的Storm簇应该有一个雨云和至少一个监督者，此外还有一个重要的节点是Apache ZooKeeper，它用于雨云和监管者之间的协作。</p>
<p>​    现在我们来仔细看一下Apache Storm的工作流</p>
<ol>
<li>最开始，雨云会等待”Storm 拓扑”提交给它。</li>
<li>当有一个拓扑提交给雨云之后，雨云会处理这个拓扑、汇总所有将要执行的任务以及给出任务执行的顺序。</li>
<li>之后，雨云会将任务平均分配给所有可用的监督者。</li>
<li>每经过一个指定的时间间隔，所有的监督者都会向雨云发送一个”心跳”来证明它们运转正常。<ol>
<li>如果有一个监督者挂了，没有向雨云发送”心跳”，那么雨云会将任务分配给另一个监督者。</li>
<li>如果雨云自己挂了，监督者们继续执行已经指定的任务，不受任何影响。<ol>
<li>当所有的任务都完成之后，监督者们会等待新任务到来。</li>
<li>与此同时，雨云会自动被服务监控工具重新启动。</li>
<li>重新启动的雨云从它停止的地方继续。</li>
</ol>
</li>
<li>事实上雨云和监督者都可以自动重启并且从原来的状态继续，因此Storm保证所有的任务至少被处理过一次。</li>
</ol>
</li>
<li>当所有的拓扑都处理完毕，雨云会等待新拓扑，监督者会等待新任务。</li>
</ol>
<ul>
<li>默认来说，Storm簇有两种模式：</li>
</ul>
<ol>
<li>本地模式Local Mode: 这个模式用于开发、测试和纠错，因为它是查看所有拓扑组件协同工作最简单的方法。在这个模式下，我们可以调整参数来查看我们的拓扑是如何运行在不同设定的Storm环境中的。在本地模式中，Storm会跑在本地机器上的一个Java虚拟机中。</li>
<li>生产模式Production Mode: 在这个模式下，我们将我们的拓扑提交给一个正在运行的Storm簇。这个Storm簇一般跑在不同的计算机上。正如前文所说，一个运行中的Storm簇会永远运行直到将它关闭。</li>
</ol>
<h1 id="安装-Apache-Storm"><a href="#安装-Apache-Storm" class="headerlink" title="安装 Apache Storm"></a>安装 Apache Storm</h1><ol>
<li>安装Java</li>
<li>安装ZooKeeper框架</li>
<li>安装Apache Storm框架</li>
</ol>
<h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><ol>
<li><code>sudo apt install python3-software-properties</code></li>
<li><code>sudo add-apt-repository ppa:webupd8team/java</code></li>
<li><code>sudo apt update</code></li>
<li><code>sudo apt install oracle-java8-installer</code>会同时自动安装<code>oracle-java8-set-default</code></li>
<li><code>java -version</code>验证安装</li>
</ol>
<h2 id="安装ZooKeeper框架"><a href="#安装ZooKeeper框架" class="headerlink" title="安装ZooKeeper框架"></a>安装ZooKeeper框架</h2><ol>
<li><p>从<code>http://zookeeper.apache.org/releases.html</code>下载最新版的ZooKeeper</p>
</li>
<li><p>解压缩</p>
</li>
<li><p>新建一个名为data的目录</p>
</li>
<li><p>编辑conf文件夹下的zoo_sample.cfg</p>
<blockquote>
<p>tickTime=2000<br>dataDir=/path/to/zookeeper/data<br>clientPort=2181</p>
</blockquote>
</li>
<li><p>启动ZooKeeper服务器<code>bin/zkServer.sh start</code></p>
</li>
</ol>
<h2 id="安装Apache-Storm框架"><a href="#安装Apache-Storm框架" class="headerlink" title="安装Apache Storm框架"></a>安装Apache Storm框架</h2><ol>
<li><p>从<code>http://storm.apache.org/downloads.html</code>下载1.1.0版本的Storm</p>
</li>
<li><p>解压缩</p>
</li>
<li><p>新建名为data的目录</p>
</li>
<li><p>编辑<code>conf/storm.yaml</code></p>
<blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; storm.zookeeper.servers:</span></span><br><span class="line"><span class="string">&gt;     - "localhost"</span></span><br><span class="line"><span class="string">&gt; storm.local.dir: "/home/wang/Storm/apache-storm-1.1.0/data"</span></span><br><span class="line"><span class="string">&gt; nimbus.host: "localhost"</span></span><br><span class="line"><span class="string">&gt; supervisor.slots.ports:</span></span><br><span class="line"><span class="string">&gt;  - 6700</span></span><br><span class="line"><span class="string">&gt;  - 6701</span></span><br><span class="line"><span class="string">&gt;  - 6702</span></span><br><span class="line"><span class="string">&gt;  - 6703</span></span><br><span class="line"><span class="string">&gt; nimbus.seeds: ["localhost"]</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>启动nimbus、supervisor和ui</p>
</li>
<li><p><code>localhost:8080</code>查看Storm ui</p>
</li>
</ol>
</p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://SEULinuxClub.github.io/2017/08/24/Storm简介/%20东南大学Linux俱乐部%20Storm简介" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2017/08/24/使用Docker和Cloud9搭建Web端IDE/" title="使用Docker和Cloud9搭建Web端IDE"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: 使用Docker和Cloud9搭建Web端IDE</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2017/06/10/概率论总结第五章/" title="概率论总结第五章">下一篇: 概率论总结第五章&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjY3Ny8xMzIxMg=="><script type="text/javascript">(function (d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') {
        return;
    }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script><noscript> Please activate JavaScript for write a comment in LiveRe</noscript></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://SEULinuxClub.github.io" rel="noopener noreferrer">SEU Linux Club</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>